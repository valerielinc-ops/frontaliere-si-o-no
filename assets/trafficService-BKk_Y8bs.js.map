{"version":3,"file":"trafficService-BKk_Y8bs.js","sources":["../../services/trafficService.ts"],"sourcesContent":["/**\n * Traffic Service - Google Maps Distance Matrix API Integration\n * Provides real-time traffic data for border crossings using Google Maps free tier\n * Protected by reCAPTCHA Enterprise to prevent API abuse\n * API key loaded from Firebase Remote Config\n */\n\n/// <reference types=\"@types/google.maps\" />\n\nimport recaptchaService from './recaptchaService';\nimport { getConfigValue } from './firebase';\nimport { borderCrossings as centralizedCrossings } from '../data/borderCrossings';\n\ninterface BorderCrossingCoordinates {\n  name: string;\n  lat: number;\n  lng: number;\n  checkpointLat: number; // Coordinate del checkpoint dopo il confine\n  checkpointLng: number;\n}\n\nexport interface TrafficData {\n  crossingName: string;\n  waitTimeMinutes: number;\n  status: 'green' | 'yellow' | 'red';\n  direction: string;\n  lastUpdate: Date;\n  source: 'google-maps' | 'mock';\n}\n\n// Build BORDER_CROSSINGS from the centralized data source (excluding closed crossings)\nconst BORDER_CROSSINGS: BorderCrossingCoordinates[] = centralizedCrossings\n  .filter(c => c.trafficLevel !== 'closed')\n  .map(c => ({\n    name: c.name,\n    lat: c.lat,\n    lng: c.lng,\n    checkpointLat: c.lat + 0.01, // ~1km north into CH\n    checkpointLng: c.lng,\n  }));\n\nclass TrafficService {\n  private apiKey: string | null = null;\n  private cache: Map<string, { data: TrafficData; timestamp: number }> = new Map();\n  private readonly CACHE_DURATION = 60 * 60 * 1000; // 1 ora (60 minuti)\n  private distanceMatrixService: google.maps.DistanceMatrixService | null = null;\n  private mapsLoaded = false;\n  private mapsLoadPromise: Promise<void> | null = null;\n  private apiKeyInitialized = false;\n\n  constructor() {\n    // API key sarà caricata da Firebase Remote Config al primo utilizzo\n    this.initApiKey();\n  }\n\n  /**\n   * Inizializza l'API key da Firebase Remote Config\n   */\n  private async initApiKey(): Promise<void> {\n    if (this.apiKeyInitialized) return;\n    \n    try {\n      this.apiKey = await getConfigValue('GOOGLE_MAPS_API_KEY');\n      this.apiKeyInitialized = true;\n      \n      if (this.hasApiKey()) {\n        console.log('✅ Google Maps API key caricata da Firebase Remote Config');\n        await this.loadGoogleMaps();\n      }\n    } catch (error) {\n      console.warn('⚠️ Errore caricamento API key da Firebase:', error);\n      // No local fallback — secrets only from Remote Config\n      this.apiKey = null;\n      this.apiKeyInitialized = true;\n    }\n  }\n\n  /**\n   * Carica dinamicamente lo script di Google Maps\n   */\n  private loadGoogleMaps(): Promise<void> {\n    if (this.mapsLoadPromise) {\n      return this.mapsLoadPromise;\n    }\n\n    this.mapsLoadPromise = new Promise((resolve) => {\n      // Se già caricato\n      if (typeof google !== 'undefined' && google.maps && google.maps.DistanceMatrixService) {\n        this.distanceMatrixService = new google.maps.DistanceMatrixService();\n        this.mapsLoaded = true;\n        resolve();\n        return;\n      }\n\n      const script = document.createElement('script');\n      script.src = `https://maps.googleapis.com/maps/api/js?key=${this.apiKey}&libraries=routes`;\n      script.async = true;\n      script.defer = true;\n      \n      script.onload = () => {\n        try {\n          if (typeof google !== 'undefined' && google.maps && google.maps.DistanceMatrixService) {\n            this.distanceMatrixService = new google.maps.DistanceMatrixService();\n            console.log('✅ Google Maps DistanceMatrixService initialized');\n          }\n          this.mapsLoaded = true;\n        } catch (error) {\n          console.error('Failed to initialize Google Maps:', error);\n        }\n        resolve();\n      };\n      \n      script.onerror = () => {\n        console.error('Failed to load Google Maps API');\n        resolve(); // Resolve comunque per non bloccare l'app\n      };\n      \n      document.head.appendChild(script);\n    });\n\n    return this.mapsLoadPromise;\n  }\n\n  /**\n   * Imposta la API key di Google Maps\n   */\n  setApiKey(key: string) {\n    this.apiKey = key;\n  }\n\n  /**\n   * Verifica se l'API key è configurata\n   */\n  hasApiKey(): boolean {\n    return this.apiKey !== null && this.apiKey !== '';\n  }\n\n  /**\n   * Ottiene i dati di traffico per tutti i valichi\n   * Protetto da reCAPTCHA per prevenire abusi API\n   */\n  async getTrafficData(): Promise<TrafficData[]> {\n    // Assicurati che l'API key sia inizializzata\n    await this.initApiKey();\n    \n    // Verifica reCAPTCHA prima di procedere con la richiesta API\n    await recaptchaService.canProceed('TRAFFIC_DATA');\n\n    if (!this.hasApiKey()) {\n      console.warn('Google Maps API key not configured. Using mock data.');\n      return this.getMockTrafficData();\n    }\n\n    try {\n      const trafficPromises = BORDER_CROSSINGS.map(crossing => \n        this.getTrafficForCrossing(crossing)\n      );\n      \n      const results = await Promise.allSettled(trafficPromises);\n      \n      return results.map((result, index) => {\n        if (result.status === 'fulfilled') {\n          return result.value;\n        } else {\n          console.error(`Error fetching traffic for ${BORDER_CROSSINGS[index].name}:`, result.reason);\n          return this.getMockTrafficForCrossing(BORDER_CROSSINGS[index].name);\n        }\n      });\n    } catch (error) {\n      console.error('Error fetching traffic data:', error);\n      return this.getMockTrafficData();\n    }\n  }\n\n  /**\n   * Ottiene i dati di traffico per un singolo valico usando Google Maps Distance Matrix API\n   */\n  private async getTrafficForCrossing(crossing: BorderCrossingCoordinates): Promise<TrafficData> {\n    const cacheKey = crossing.name;\n    const cached = this.cache.get(cacheKey);\n    \n    if (cached && Date.now() - cached.timestamp < this.CACHE_DURATION) {\n      return cached.data;\n    }\n\n    // Attendi il caricamento di Google Maps\n    if (this.hasApiKey() && !this.mapsLoaded) {\n      await this.loadGoogleMaps();\n    }\n\n    // Se il servizio non è disponibile, usa i dati mock\n    if (!this.distanceMatrixService) {\n      return this.getMockTrafficForCrossing(crossing.name);\n    }\n\n    try {\n      const origin = new google.maps.LatLng(crossing.lat, crossing.lng);\n      const destination = new google.maps.LatLng(crossing.checkpointLat, crossing.checkpointLng);\n      \n      // Chiamata al Distance Matrix Service\n      const result = await new Promise<google.maps.DistanceMatrixResponse>((resolve, reject) => {\n        this.distanceMatrixService!.getDistanceMatrix(\n          {\n            origins: [origin],\n            destinations: [destination],\n            travelMode: google.maps.TravelMode.DRIVING,\n            drivingOptions: {\n              departureTime: new Date(),\n              trafficModel: google.maps.TrafficModel.BEST_GUESS\n            },\n            unitSystem: google.maps.UnitSystem.METRIC\n          },\n          (response, status) => {\n            if (status === 'OK' && response) {\n              resolve(response);\n            } else {\n              reject(new Error(`Distance Matrix API error: ${status}`));\n            }\n          }\n        );\n      });\n      \n      const element = result.rows[0]?.elements[0];\n      \n      if (!element || element.status !== 'OK') {\n        throw new Error(`Route error: ${element?.status || 'NO_DATA'}`);\n      }\n      \n      // Tempo con traffico in secondi\n      const durationInTraffic = element.duration_in_traffic?.value || element.duration.value;\n      // Tempo normale senza traffico\n      const normalDuration = element.duration.value;\n      \n      // Calcola il ritardo in minuti\n      const delaySeconds = durationInTraffic - normalDuration;\n      const waitTimeMinutes = Math.max(0, Math.round(delaySeconds / 60));\n      \n      // Determina lo stato in base al ritardo\n      let status: 'green' | 'yellow' | 'red';\n      if (waitTimeMinutes < 5) {\n        status = 'green';\n      } else if (waitTimeMinutes < 15) {\n        status = 'yellow';\n      } else {\n        status = 'red';\n      }\n      \n      // Determina la direzione in base all'ora\n      const hour = new Date().getHours();\n      let direction: string;\n      if (hour >= 6 && hour < 10) {\n        direction = 'IT → CH';\n      } else if (hour >= 16 && hour < 20) {\n        direction = 'CH → IT';\n      } else {\n        direction = 'Entrambi';\n      }\n      \n      const trafficData: TrafficData = {\n        crossingName: crossing.name,\n        waitTimeMinutes,\n        status,\n        direction,\n        lastUpdate: new Date(),\n        source: 'google-maps'\n      };\n      \n      // Salva in cache\n      this.cache.set(cacheKey, {\n        data: trafficData,\n        timestamp: Date.now()\n      });\n      \n      return trafficData;\n    } catch (error) {\n      console.error(`Error fetching traffic for ${crossing.name}:`, error);\n      // Fallback a dati mock in caso di errore\n      return this.getMockTrafficForCrossing(crossing.name);\n    }\n  }\n\n  /**\n   * Genera dati mock di traffico per tutti i valichi (fallback)\n   */\n  private getMockTrafficData(): TrafficData[] {\n    return BORDER_CROSSINGS.map(crossing => \n      this.getMockTrafficForCrossing(crossing.name)\n    );\n  }\n\n  /**\n   * Genera dati mock di traffico per un singolo valico\n   */\n  private getMockTrafficForCrossing(crossingName: string): TrafficData {\n    const hour = new Date().getHours();\n    const dayOfWeek = new Date().getDay();\n    \n    let baseWait = 3;\n    let direction = 'Entrambi';\n    \n    // Chiasso variants have more traffic\n    if (crossingName.includes('Chiasso')) {\n      baseWait = 8;\n    }\n    \n    // Major crossings have more traffic\n    if (crossingName.includes('Gaggiolo') || crossingName.includes('Brogeda')) {\n      baseWait = 6;\n    }\n    \n    // Medium crossings\n    if (crossingName.includes('Ponte Tresa') || crossingName.includes('San Pietro') || crossingName.includes('Luino')) {\n      baseWait = 5;\n    }\n    \n    // Picco mattutino (7-9) IT -> CH\n    if (hour >= 7 && hour < 9) {\n      baseWait *= (crossingName.includes('Chiasso') ? 3 : 2);\n      direction = 'IT → CH';\n    }\n    \n    // Picco serale (17-19) CH -> IT\n    if (hour >= 17 && hour < 19) {\n      baseWait *= (crossingName.includes('Chiasso') ? 4 : 2.5);\n      direction = 'CH → IT';\n    }\n    \n    // Venerdì sera più traffico\n    if (dayOfWeek === 5 && hour >= 16) {\n      baseWait *= 1.5;\n    }\n    \n    // Domenica sera traffico moderato\n    if (dayOfWeek === 0 && hour >= 17) {\n      baseWait *= 1.3;\n    }\n    \n    // Aggiungi variazione casuale ±30%\n    const variation = 0.7 + Math.random() * 0.6;\n    const waitTimeMinutes = Math.round(baseWait * variation);\n    \n    let status: 'green' | 'yellow' | 'red';\n    if (waitTimeMinutes < 5) {\n      status = 'green';\n    } else if (waitTimeMinutes < 15) {\n      status = 'yellow';\n    } else {\n      status = 'red';\n    }\n    \n    return {\n      crossingName,\n      waitTimeMinutes,\n      status,\n      direction,\n      lastUpdate: new Date(),\n      source: 'mock'\n    };\n  }\n\n  /**\n   * Pulisce la cache\n   */\n  clearCache() {\n    this.cache.clear();\n  }\n}\n\nexport const trafficService = new TrafficService();\n"],"names":["BORDER_CROSSINGS","centralizedCrossings","c","TrafficService","getConfigValue","error","resolve","script","key","recaptchaService","trafficPromises","crossing","result","index","cacheKey","cached","origin","destination","element","_a","reject","response","status","durationInTraffic","_b","normalDuration","delaySeconds","waitTimeMinutes","hour","direction","trafficData","crossingName","dayOfWeek","baseWait","variation","trafficService"],"mappings":"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"}